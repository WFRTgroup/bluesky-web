#! /usr/bin/env python3

"""For adhoc testing BlueSkyRunner class.
"""

__author__ = "Joel Dubowy"
__copyright__ = "Copyright 2017, AirFire, PNW, USFS"

import datetime
import io
import json
import logging
import os
import sys
import uuid

import afscripting as scripting

sys.path.insert(0, os.path.abspath(os.path.join(sys.path[0], '../../')))

# Note: tornado, blueskyweb.app.configure_logging and
#   from blueskyworker.tasks are imported inline so that
#   the you can run this script with `-h` without needing tornado
#   and other python pacakges installed in your local (non-docker)
#   python env
from blueskyconfig.defaults import DEFAULTS



# Note: the trailing space seems to be the only way to add an extra trailing line
EPILOG_STR = """
Examples:

Run in docker. e.g.:

 $ docker run -ti -v $PWD:/usr/src/blueskyweb/ -w /usr/src/blueskyweb/ \\
    bluesky-web {script_name} --log-level=DEBUG --mode normal

 $ docker run -ti -v $PWD:/usr/src/blueskyweb/ -w /usr/src/blueskyweb/ \\
    bluesky-web {script_name} --log-level=DEBUG --mode normal -r

 $ docker run -ti -v $PWD:/usr/src/blueskyweb/ -w /usr/src/blueskyweb/ \\
    -v $HOME/Met:/data/Met/ -v $PWD/docker-data/output/:/data/bluesky/output/ \\
    bluesky-web {script_name} --record-run --log-level=DEBUG --mode dispersion \\
    -s 2014-05-30T00:00:00 -n 12 --met-archive ca-nv_6-km

 $ docker exec -ti bluesky-web-worker \\
    {script_name} --record-run --log-level=DEBUG --mode dispersion \\
    -s 2014-05-30T00:00:00 -n 12 --met-archive ca-nv_6-km \\
    --mongodb-url mongodb://blueskyweb:blueskywebmongopassword@mongo/blueskyweb

""".format(script_name=sys.argv[0])

MODES = {
    'normal':['ingestion', 'fuelbeds'],
    'double-fuelbeds': ['ingestion', 'fuelbeds', 'fuelbeds'],
    'invalid-input': ['ingestion', 'fuelbeds', 'emissions'],
    'invalid-module':['ingestion', 'fuelbeds', 'emissionssdf'],
    'dispersion':['ingestion', 'fuelbeds', 'consumption', 'emissions',
        'timeprofiling', 'plumerising', 'findmetdata', 'dispersion']
}

REQUIRED_ARGS = [
    {
        'long': '--mode',
        'help': ', '.join(list(MODES.keys()))
    }
]

_NOW = datetime.datetime.utcnow()
OPTIONAL_ARGS = [
    {
        'short': '-m',
        'long': '--mongodb-url',
        'help': ('url to connect to mongodb for arl '
            'indexes and bsp job queues'),
        'default': "mongodb://blueskyweb:blueskywebmongopassword@localhost:27018/blueskyweb"
    },
    {
        'short': '-r',
        'long': '--record-run',
        'help': 'record run in db and write output to file',
        'action': 'store_true',
        'default': False
    },
    {
        'short': '-s',
        'long': '--start',
        'help': "UTC start time of hysplit run; e.g. '2015-08-15T00:00:00'",
        'action': scripting.args.ParseDatetimeAction,
        'default': datetime.datetime(_NOW.year, _NOW.month, _NOW.day)
    },
    {
        'short': '-n',
        'long': '--num-hours',
        'help': 'number of hours in hysplit run',
        "type": int,
        'default': 12
    },
    {
        'short': '-a',
        'long': '--area',
        'help': 'area of fire, in acres; default 10000',
        "type": float,
        'default': 10000.0
    },
    {
        'long': "--latitude",
        'help': 'latitude of fire location; default: 37.909644',
        'default':  37.909644,
        'type': float
    },
    {
        'long': "--longitude",
        'help': 'longitude of fire location; default: -119.7615805',
        'default': -119.7615805,
        'type': float
    },
    {
        'long': "--utc-offset",
        'help': 'utc offest of fire location; default: "-07:00"',
        'default': '-07:00'
    },
    {
        'long': "--met-archive",
        'help': "met archive; default 'ca-nv_6-km'",
        'default': 'DRI6km'
    }
]

RUN_ID = 'blueskyrunner-' + _NOW.strftime('%Y%m%dT%H%M%S')
INPUT = {
    "run_id": RUN_ID,
    "config": {
        "emissions": {
            "species": ["PM2.5"]
        },
        "findmetdata": {
            "arl": {
                "fewer_arl_files": True,
                "index_filename_pattern": None,  # WILL BE FILLED IN
            },
            "met_root_dir": None  # WILL BE FILLED IN
        },
        "dispersion": {
            "start": None,  # WILL BE FILLED IN
            "num_hours": None,  # WILL BE FILLED IN
            "output_dir": "/data/bluesky/{}/output".format(RUN_ID),
            "working_dir": "/data/bluesky/{}/working".format(RUN_ID),
            'hysplit': {
                "DELT": 0.0,
                "INITD": 0,
                "KHMAX": 72,
                "MAXPAR": 1000000000,
                "MPI": True,
                "NCPUS": 2,
                "NINIT": 0,
                "NUMPAR": 1000,
                "VERTICAL_EMISLEVELS_REDUCTION_FACTOR": 5,
                "VERTICAL_LEVELS": [
                    100
                ],
                "grid": None,  # WILL BE FILLED IN
            }
        },
        "export": {
            "extra_exports": ["dispersion", "visualization", "extrafiles"]
        }
    },
    "fire_information": [
        {
            "event_of": {
                "id": "SF11E826544",
                "name": "Natural Fire near Yosemite, CA"
            },
            "id": "SF11C14225236095807750",
            "type": "wildfire",
            "fuel_type": "natural",
            "growth": [
                {
                    "start": None,  # WILL BE FILLED IN
                    "end": None,  # WILL BE FILLED IN
                    "location": {
                        "area": None,  # WILL BE FILLED IN
                        "ecoregion": "western",
                        "latitude": None,  # WILL BE FILLED IN
                        "longitude": None,  # WILL BE FILLED IN
                        "utc_offset": None,  # WILL BE FILLED IN
                    }
                }
            ]
        }
    ]
}

def parse_args():
    parser = scripting.args.ArgumentParser()
    parser.epilog = EPILOG_STR
    parser.formatter_class = scripting.args.RawTextHelpFormatter
    scripting.args.add_arguments(parser, OPTIONAL_ARGS)
    scripting.args.add_arguments(parser, REQUIRED_ARGS, required=True)
    # Use afscripting to add logging options to the parser object,
    # but we'll configure logging oureselves
    scripting.args.add_logging_options(parser)
    args = parser.parse_args()
    args.log_message_format = (args.log_message_format
        or "%(asctime)s %(levelname)s %(filename)s#%(funcName)s: %(message)s")
    from blueskyweb.app import configure_logging
    configure_logging(**args.__dict__)
    return args

MET_ROOT_DIRS = {
    "national_12-km": "/data/Met/NAM/12km/ARL/",
    "national_3-km": "/data/Met/NAM/3km/ARL/",
    "pacific_northwest_1.33-km": "/data/Met/PNW/1.33km/ARL/",
    "pacific_northwest_4-km": "/data/Met/PNW/4km/ARL/",
    "ca-nv_2-km": "/data/Met/CANSAC/2km/ARL/",
    "ca-nv_6-km": "/data/Met/CANSAC/6km/ARL/"
}
DT_STR = '%Y-%m-%dT%H:%M:%S'
def get_input(args):
    archive = (DEFAULTS['archives']['standard'].get(args.met_archive)
        or DEFAULTS['archives']['fast'].get(args.met_archive)
        or DEFAULTS['archives']['special'].get(args.met_archive))
    if not archive or args.met_archive not in MET_ROOT_DIRS:
        print('** ERROR - Archive not supported: %s', args.met_archive)
        print('**    (choose from  %s)', ', '.join(list(MET_ROOT_DIRS.keys())))

    domain = DEFAULTS['domains'][archive['domain_id']]
    INPUT['config']['findmetdata']['arl']['index_filename_pattern'] = domain['arl_index_file']
    INPUT['config']['findmetdata']['met_root_dir'] = MET_ROOT_DIRS[args.met_archive]

    start_str = args.start.strftime(DT_STR)
    INPUT['config']['dispersion']['start'] = start_str
    INPUT['config']['dispersion']['num_hours'] = args.num_hours
    INPUT['config']['dispersion']['hysplit']['grid'] = domain['grid']
    local_start_str = (
        args.start + datetime.timedelta(hours=-7)).strftime(DT_STR)
    local_end_str = (
        args.start + datetime.timedelta(hours=args.num_hours-7)).strftime(DT_STR)
    INPUT['fire_information'][0]['growth'][0]['start'] = local_start_str
    INPUT['fire_information'][0]['growth'][0]['end'] = local_end_str
    INPUT['fire_information'][0]['growth'][0]['location']['area'] = args.area
    INPUT['fire_information'][0]['growth'][0]['location']['latitude'] = args.latitude
    INPUT['fire_information'][0]['growth'][0]['location']['longitude'] = args.longitude
    INPUT['fire_information'][0]['growth'][0]['location']['utc_offset'] = args.utc_offset

    if args.mode not in MODES:
        print('** ERROR - Invalid Mode: %s', args.mode)
        print('**    (choose from  %s)', ', '.join(list(MODES.keys())))
    INPUT['modules'] = MODES[args.mode]

    return INPUT

async def main(args):
    input = get_input(args)

    from blueskyworker import tasks
    if args.record_run:
        db = tasks.BlueSkyWebDB(args.mongodb_url)
        logging.debug('About to run BlueSkyRunner')
        tasks.BlueSkyRunner(INPUT, db=db,
            output_root_dir='dev',
            output_url_path_prefix="blueskyrunner-logs",
            bluesky_log_level=logging.DEBUG).run()
        logging.debug('Done running BlueSkyRunner')
        run_info = await db.find_run(RUN_ID)
        sys.stdout.write(json.dumps(run_info))

    else:
        s = io.StringIO()
        logging.debug('About to run BlueSkyRunner')
        output = tasks.BlueSkyRunner(INPUT, output_stream=s).run()
        logging.debug('About to dump to stdout')
        sys.stdout.write(s.getvalue())

if __name__ == "__main__":
    args = parse_args()

    from functools import partial
    main = partial(main, args=args)
    import tornado.ioloop
    tornado.ioloop.IOLoop.instance().run_sync(main)
